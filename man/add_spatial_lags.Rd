% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add-spatial-lags.R
\name{add_spatial_lags}
\alias{add_spatial_lags}
\title{Add Spatial Lags of a Variable to a Dataset}
\usage{
add_spatial_lags(nblist, y, .data, lags, type = NULL, parallel = FALSE, ...)
}
\arguments{
\item{nblist}{An object of class "nb" from the spdep package which represents the neighborhood structure.}

\item{y}{A character string indicating the name of the numeric variable in \code{.data}
for which spatial lags will be computed.}

\item{.data}{A data frame of class "sf" containing the variable specified by \code{y}.}

\item{lags}{A numeric value specifying the number of spatial lags to compute.}

\item{type}{A character string indicating the type of spatial weights to use.
Accepted values are \code{"idw"} (inverse distance weighting), \code{"exp"} (exponential),
\code{"dpd"} (double power decay), or \code{NULL} (default), which applies standard
adjacency-based weighting.}

\item{parallel}{(default: FALSE) Logical indicating whether to use parallel processing.
Requires having purrr (>= 1.0.4.9000) installed, \href{https://shikokuchuo.net/mirai/}{mirai (>= 2.1.0.9000)} package installed and loaded, and setting \code{mirai::daemons()} to the number of desired processes. (See Examples)}

\item{...}{Additional arguments passed to \code{spdep::nb2listw()} or \code{spdep::nb2listwdist()},
such as the \code{style} argument specifying the normalization method or \code{zero-policy} which indicates whether or not to permit the weights list to be formed with zero-length weights vectors.}
}
\value{
A tibble containing the original dataset with additional columns for each
computed spatial lag. The spatial lag columns are named \code{"spatlag_<lag>_<y>"}.
The output also includes weight summary attributes named \code{"summ_wgts_spatlag_<lag>"}.
}
\description{
Computes spatial lags for a given numeric variable in a dataset using
a neighborhood list from the \href{https://r-spatial.github.io/spdep/}{spdep} package. It supports inverse distance weighting, exponential, and double power decay weighting methods along with various normalization procedures.
}
\details{
To obtain a neighborhood list of class "nb," first, a neighborhood algorithm is fit to the geometry of sf dataset. Then, that object is coerced into a neighborhood list. For a workflow, see the Misc section in the \href{https://ercbk.github.io/Data-Science-Notebook/qmd/geospatial-spatial-weights.html#sec-geo-swgt-misc}{Geospatial, Spatial Weights} note of my Data Science notebook.
\itemize{
\item Valid Types: (\code{"idw"}, \code{"exp"}, \code{"dpd"}).
\item Valid Styles: (\code{"W"}, \code{"B"}, \code{"C"}, \code{"S"}, \code{"U"}, \code{"minmax"}, \code{"raw"}).
\item See the Spatial Weights section in the \href{https://ercbk.github.io/Data-Science-Notebook/qmd/geospatial-spatial-weights.html#sec-geo-swgt-swts}{Geospatial, Spatial Weights} note of my Data Science notebook for details
}

The spatial weights summary is extracted from the output of printing the \code{spdep::nb2listw} or \code{spdep::nb2listwdist} object. It contains characteristics such as the number of regions, number of nonzero links, percentage of nonzero weights, average number of links.
\itemize{
\item n: This refers to the number of regions (or spatial units) in your dataset.
\item nn: This refers to the total number of possible pairwise relationships between the regions. It is calculated as n Ã— n. This represents the total number of possible links if every region were connected to every other region, including itself.
\item S0: This is the sum of all weights.
\item S1: This is related to the sum of the squares of the weights.
\item S2: This is related to the sum of the products of the weights for each pair of neighbors.
\item S0, S1, S2 are constants used in inference for global spatial autocorrelation statistics
}
}
\examples{

library(spdep, quietly = TRUE)

ny8_sf <-
  st_read(system.file(
    "shapes/NY8_bna_utm18.gpkg",
    package = "spData"),
    quiet = TRUE)

dplyr::glimpse(ny8_sf)

ny8_ct_sf <-
  st_centroid(st_geometry(ny8_sf),
              of_largest_polygon = TRUE)


ny88_nb_sf <-
  knn2nb(knearneigh(ny8_ct_sf,
                    k = 4))

# Compute spatial lags
tib_spat_lags <-
  add_spatial_lags(
    nblist = ny88_nb_sf,
    y = "PCTOWNHOME",
    .data = ny8_sf,
    lags = 2,
    type = "dpd",
    dmax = 25000,
    style = "W",
    zero.policy = TRUE
  )

tib_spat_lags |>
  dplyr::select(PCTOWNHOME,
                spatlag_1_PCTOWNHOME,
                spatlag_2_PCTOWNHOME) |>
  dplyr::glimpse()

cat(attributes(tib_spat_lags)$summ_wgts_spatlag_1, sep = "\n")

rlang::check_installed(
  "mirai (>= 2.1.0.9000)",
  action = function(...) {
    remotes::install_version('mirai',
                             version = ">= 2.1.0.9000",
                             repos = c('https://shikokuchuo.r-universe.dev',
                                       'https://cloud.r-project.org'))
  }
)

library(mirai)

daemons(2)

tib_spat_lags_para <-
  add_spatial_lags(
    nblist = ny88_nb_sf,
    y = "PCTOWNHOME",
    .data = ny8_sf,
    lags = 2,
    type = "exp",
    zero.policy = TRUE,
    parallel = TRUE
  )

daemons(0)
}
